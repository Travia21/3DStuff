"use strict";

import * as THREE from 'three';
import * as SHAPES from './shapes';
import * as MAIN from '../main';

/**
 * 
 * @param {THREE.Vector3} position 
 */
export function draw(position = new THREE.Vector3(0,0,0)) {
    if (!(position instanceof THREE.Vector3)) {
        throw new TypeError("COMPLEX.draw() expects a THREE.Vector3")
    }

    // How do I compose a complex object?
}

/*  Creates a scene that shows an object that is created by "lathing".  That is,
 *  a surface is generated by taking a curve the lies in the xz-plane and rotating
 *  it around the y-axis.  A copy of the curve is also shown, moved 5 units away
 *  from the surface so that it can be seen.  For viewing, the combined objects
 *  are rotated so that the axis of the lathed object lies along the x-axis.
 */
export function functionLathe() {
    var material = new THREE.MeshPhongMaterial({
        color: "white",
        specular: 0x080808,
        side: THREE.DoubleSide,
        map: getTexture()
    });
    
    /*  Create a cosine curve in the xy-plane to define the points for the lathe.  We could
     *  define an array of points directly, but it's nice to use a THREE.Curve to do it.
     *  The curve is defiend by a the function x = 3 + 2*cos(z)
     */
    let cosine = new THREE.Curve();
    cosine.getPoint = function(t) {
        let s = (t - 0.5) * 4*Math.PI;
        return new THREE.Vector3(
            3 + Math.cos(s), s, 0
        );
    }
    /*
    cosine.getPoint = function(t) {
        t = (t - 0.5) * 6*Math.PI; // changes the domain to cover a greater range
        return new THREE.Vector3(
            3 + 2*Math.cos(t), // i don't see how setting x is correct
            0,
            t
        );
    }
    */

    /*  A lathed object is created using an array of points. The points should have y-coordinate
     *  equal to zero.  In this case, cosine.getPoints(128) produces an array of 128 points that
     *  lie along the curve.  The lines connecting the points are rotated about the y-axis to
     *  generate a surface. The second paramter is the number of radial subdivisions of the surface.
     */
    let latheGeometry = new THREE.LatheGeometry(cosine.getPoints(128), 32);
    let latheObj = new THREE.Mesh(latheGeometry, material);
    
    /* I also make a basic line geometry from the same array of points.  This would lie along
     * the surface, but I move it 5 units to the right to make it visible.
     */
    let curveGeom = new THREE.BufferGeometry();
    curveGeom.vertices = cosine.getPoints(128);
    let curve = new THREE.Line(curveGeom, new THREE.LineBasicMaterial({ color:0xffffff, linewidth:2 }));
    curve.position.x = 5;
    //curve.rotation.x = -Math.PI/2;
    //latheObj.add(curve);

    //obj.rotation.z = Math.PI/2;
    //scene.add(obj);
    return latheObj;
}

function getTexture() {
    let loader = new THREE.TextureLoader();
    let texture = loader.load('../static/unnamed.jpg', MAIN.render);
    texture.colorSpace = THREE.SRGBColorSpace;
    return texture;
}